#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright 2018 University of Groningen
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
High level API for Martinize2
"""

import argparse
from pathlib import Path
import os
import numpy as np
import vermouth
from vermouth.forcefield import find_force_fields, FORCE_FIELDS
from vermouth import DATA_PATH
from vermouth.dssp.dssp import (
    AnnotateDSSP,
    AnnotateMartiniSecondaryStructures,
    AnnotateResidues,
)
from vermouth import selectors
from vermouth.map_input import read_mapping_directory
import itertools
import operator
import textwrap


def read_system(path):
    """
    Read a system from a PDB or GRO file.

    This function guesses the file type based on the file extension.

    The resulting system does not have a force field and may not have edges.
    """
    system = vermouth.System()
    file_extension = path.suffix.upper()[1:]  # We do not keep the dot
    if file_extension in ['PDB', 'ENT']:
        vermouth.PDBInput().run_system(system, str(path))
    elif file_extension in ['GRO']:
        vermouth.GROInput().run_system(system, str(path))
    else:
        raise ValueError('Unknown file extension "{}".'.format(file_extension))
    return system


def pdb_to_universal(system, delete_unknown=False):
    """
    Convert a system read from the PDB to a clean canonical atomistic system.
    """
    canonicalized = system.copy()
    canonicalized.force_field = FORCE_FIELDS['universal']
    vermouth.MakeBonds().run_system(canonicalized)
    vermouth.RepairGraph(delete_unknown=delete_unknown).run_system(canonicalized)
    vermouth.AttachMass(attribute='mass').run_system(canonicalized)
    return canonicalized


def martinize(system, mappings, to_ff, delete_unknown=False):
    """
    Convert a system from one force field to an other at lower resolution.
    """
    vermouth.DoMapping(mappings=mappings,
                       to_ff=to_ff,
                       delete_unknown=delete_unknown,
                       attribute_keep=('cgsecstruct', )).run_system(system)
    vermouth.DoAverageBead(ignore_missing_graphs=True).run_system(system)
    vermouth.ApplyBlocks().run_system(system)
    vermouth.DoLinks().run_system(system)
    vermouth.LocateChargeDummies().run_system(system)
    return system


def write_gmx_topology(system, top_path):
    if not system.molecules:
        raise ValueError('No molecule in the system. Nothing to write.')
    # Deduplicate the moleculetypes in order to write each molecule ITP only
    # once.
    molecule_types = [[system.molecules[0], [system.molecules[0]]], ]
    for molecule in system.molecules[1:]:
        for molecule_type, share_moltype in molecule_types:
            if molecule.share_moltype_with(molecule_type):
                share_moltype.append(molecule)
                break
        else:  # no break
            molecule_types.append([molecule, [molecule, ]])
    # Write the ITP files for the moleculetypes.
    for molidx, (molecule_type, _) in enumerate(molecule_types):
        molecule_type.moltype = 'molecule_{}'.format(molidx)
        with open('molecule_{}.itp'.format(molidx), 'w') as outfile:
            vermouth.gmx.itp.write_molecule_itp(molecule_type, outfile)
    # Reorganize the molecule type assignment to write the top file.
    # The top file "molecules" section lists the molecules in the same order
    # as in the structure and group them. To do the grouping, we associate each
    # molecule to the molecule type (its name actually) instead of associating
    # the molecule types with the molecules as we did above.
    molecule_to_type = {}
    for molecule_type, share_moltype in molecule_types:
        for molecule in share_moltype:
            molecule_to_type[molecule] = molecule_type.moltype
    # Write the top file
    max_name_length = max(len(molecule_type.moltype)
                          for molecule_type, _ in molecule_types)
    template = textwrap.dedent("""\
        #include "martini.itp"
        {includes}

        [ system ]
        Title of the system

        [ molecules ]
        {molecules}
    """)
    include_string = '\n'.join(
        '#include "{}.itp"'.format(molecule_type.moltype)
        for molecule_type, _ in molecule_types
    )
    molecule_groups = itertools.groupby(system.molecules,
                                        key=lambda x: molecule_to_type[x])
    molecule_string = '\n'.join(
        '{mtype:<{length}}    {num}'
        .format(mtype=mtype, num=len(list(group)), length=max_name_length)
        for mtype, group in molecule_groups
    )
    with open(str(top_path), 'w') as outfile:
        outfile.write(
            textwrap.dedent(
                template.format(
                    includes=include_string,
                    molecules=molecule_string
                )
            )
        )


def entry():
    parser = argparse.ArgumentParser()
    parser.add_argument('-f', dest='inpath', required=True, type=Path)
    parser.add_argument('-x', dest='outpath', required=True, type=Path)
    parser.add_argument('-o', dest='top_path', type=Path)
    parser.add_argument('-p', dest='posres',
                        choices=('None', 'All', 'Backbone'), default='None')
    parser.add_argument('-pf', dest='posres_fc', type=float, default=500)
    parser.add_argument('-ff', dest='to_ff', default='martini22')
    parser.add_argument('-dssp', nargs='?', const='dssp')
    parser.add_argument('-ed', dest='extdih', action='store_true', default=False) 
    parser.add_argument('-collagen', action='store_true', default=False)
    parser.add_argument('-elastic', action='store_true', default=False)
    parser.add_argument('-ef', dest='rb_force_constant', type=float, default=500)
    parser.add_argument('-el', dest='rb_lower_bound', type=float, default=0.5)
    parser.add_argument('-eu', dest='rb_upper_bound', type=float, default=0.9)
    parser.add_argument('-ea', dest='rb_decay_factor', type=float, default=0)
    parser.add_argument('-ep', dest='rb_decay_power', type=float, default=0)
    parser.add_argument('-em', dest='rb_minimum_force', type=float, default=0)
    parser.add_argument('-nt', dest='neutral_terminii',
                        action='store_true', default=False)
    args = parser.parse_args()

    known_force_fields = vermouth.forcefield.find_force_fields(
        Path(DATA_PATH) / 'force_fields'
    )
    known_mappings = read_mapping_directory(Path(DATA_PATH) / 'mappings')

    from_ff = 'universal'
    if args.to_ff not in known_force_fields:
        raise ValueError('Unknown force field "{}".'.format(args.to_ff))
    if from_ff not in known_mappings or args.to_ff not in known_mappings[from_ff]:
        raise ValueError('No mapping known to go from "{}" to "{}".'
                         .format(from_ff, args.to_ff))

    # Reading the input structure.
    # So far, we assume we only go from atomistic to martini. We want the
    # input structure to be a clean universal system.
    # For now at least, we silently delete molecules with unknown blocks.
    system = read_system(args.inpath)
    system = pdb_to_universal(system, delete_unknown=True)

    if args.dssp is not None:
        AnnotateDSSP(executable=args.dssp, savedir='.').run_system(system)
        AnnotateMartiniSecondaryStructures().run_system(system)
    elif args.collagen:
        AnnotateResidues(attribute='cgsecstruct', sequence='F',
                         molecule_selector=selectors.is_protein).run_system(system)
    vermouth.SetMoleculeMeta(extdih=args.extdih).run_system(system)
    vermouth.SetMoleculeMeta(neutral_terminii=args.neutral_terminii).run_system(system)

    # Run martinize on the system.
    system = martinize(
        system,
        mappings=known_mappings,
        to_ff=known_force_fields[args.to_ff],
        delete_unknown=True,
    )

    # Apply a rubber band elastic network is required.
    if args.elastic:
        rubber_band_processor = vermouth.ApplyRubberBand(
            lower_bound=args.rb_lower_bound,
            upper_bound=args.rb_upper_bound,
            decay_factor=args.rb_decay_factor,
            decay_power=args.rb_decay_power,
            base_constant=args.rb_force_constant,
            minimum_force=args.rb_minimum_force,
        )
        rubber_band_processor.run_system(system)

    # Apply position restraints if required.
    if args.posres != 'None':
        node_selectors = {'All': selectors.select_all,
                          'Backbone': selectors.select_backbone}
        node_selector = node_selectors[args.posres]
        vermouth.ApplyPosres(node_selector, args.posres_fc).run_system(system)

    # For demonstration purpose, write the secondary structure assignation
    # instead of the element.
    # TODO: remove this code for production
    for molecule in system.molecules:
        for atom in molecule.nodes.values():
            atom['element'] = atom.get('cgsecstruct', 'X')

    # Write a PDB file.
    vermouth.pdb.write_pdb(system, str(args.outpath))

    if args.top_path is not None:
        write_gmx_topology(system, args.top_path)


if __name__ == '__main__':
    entry()
